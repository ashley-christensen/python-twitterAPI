"use strict";
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _Client_instances, _Client_fetchClientUser, _Client_connectToFilteredStream, _Client_connectToSampledStream;
Object.defineProperty(exports, "__esModule", { value: true });
exports.Client = void 0;
const BaseClient_1 = require("./BaseClient");
const RESTManager_1 = require("../rest/RESTManager");
const util_1 = require("../util");
const errors_1 = require("../errors");
const managers_1 = require("../managers");
const structures_1 = require("../structures");
const node_stream_1 = require("node:stream");
const books_1 = require("../books");
class Client extends BaseClient_1.BaseClient {
    constructor(options) {
        super(options);
        _Client_instances.add(this);
        Object.defineProperty(this, 'token', { writable: true, enumerable: false });
        this.token = null;
        Object.defineProperty(this, 'credentials', { writable: true, enumerable: false });
        this.credentials = null;
        this.me = null;
        this.readyAt = null;
        this.rest = new RESTManager_1.RESTManager(this);
        this.tweets = new managers_1.TweetManager(this);
        this.users = new managers_1.UserManager(this);
        this.spaces = new managers_1.SpaceManager(this);
        this.lists = new managers_1.ListManager(this);
        this.filteredStreamRules = new managers_1.FilteredStreamRuleManager(this);
    }
    get _api() {
        return this.rest.routeBuilder;
    }
    async loginWithBearerToken(token) {
        if (typeof token !== 'string') {
            throw new errors_1.CustomTypeError('INVALID_TYPE', 'token', 'string', false);
        }
        this.token = token;
        this.readyAt = new Date();
        this.emit(util_1.ClientEvents.READY, this);
        if (this.options.events.includes('FILTERED_TWEET_CREATE')) {
            __classPrivateFieldGet(this, _Client_instances, "m", _Client_connectToFilteredStream).call(this);
        }
        if (this.options.events.includes('SAMPLED_TWEET_CREATE')) {
            __classPrivateFieldGet(this, _Client_instances, "m", _Client_connectToSampledStream).call(this);
        }
        return this.token;
    }
    async login(credentials) {
        if (typeof credentials !== 'object') {
            throw new errors_1.CustomTypeError('INVALID_TYPE', 'credentials', 'object', true);
        }
        this.credentials = new structures_1.ClientCredentials(credentials);
        this.token = this.credentials.bearerToken;
        this.readyAt = new Date();
        this.me = await __classPrivateFieldGet(this, _Client_instances, "m", _Client_fetchClientUser).call(this);
        if (!this.me)
            throw new errors_1.CustomError('USER_CONTEXT_LOGIN_ERROR');
        this.emit(util_1.ClientEvents.READY, this);
        if (this.options.events.includes('FILTERED_TWEET_CREATE')) {
            __classPrivateFieldGet(this, _Client_instances, "m", _Client_connectToFilteredStream).call(this);
        }
        if (this.options.events.includes('SAMPLED_TWEET_CREATE')) {
            __classPrivateFieldGet(this, _Client_instances, "m", _Client_connectToSampledStream).call(this);
        }
        return this.credentials;
    }
    createBook(bookName, options) {
        return new Books[bookName](this, options);
    }
}
exports.Client = Client;
_Client_instances = new WeakSet(), _Client_fetchClientUser = async function _Client_fetchClientUser() {
    const queryParameters = this.options.queryParameters;
    const query = {
        expansions: queryParameters?.userExpansions,
        'tweet.fields': queryParameters?.tweetFields,
        'user.fields': queryParameters?.userFields,
    };
    const requestData = new structures_1.RequestData({ query, isUserContext: true });
    const data = await this._api.users.me.get(requestData);
    return new structures_1.ClientUser(this, data);
}, _Client_connectToFilteredStream = async function _Client_connectToFilteredStream() {
    const queryParameters = this.options.queryParameters;
    const query = {
        expansions: queryParameters?.tweetExpansions,
        'media.fields': queryParameters?.mediaFields,
        'place.fields': queryParameters?.placeFields,
        'poll.fields': queryParameters?.pollFields,
        'tweet.fields': queryParameters?.tweetFields,
        'user.fields': queryParameters?.userFields,
    };
    const requestData = new structures_1.RequestData({ query, isStreaming: true });
    const res = await this._api.tweets.search.stream.get(requestData);
    if (!res.body)
        throw Error('No response body');
    const readableStream = node_stream_1.Readable.from(res.body, { encoding: 'utf-8' });
    readableStream.on('data', chunk => {
        try {
            const rawData = JSON.parse(chunk);
            const tweet = this.tweets._add(rawData.data.id, rawData, false);
            const matchingRules = rawData.matching_rules.reduce((col, rule) => {
                col.set(rule.id, new structures_1.MatchingRule(rule));
                return col;
            }, new util_1.Collection());
            this.emit(util_1.ClientEvents.FILTERED_TWEET_CREATE, tweet, matchingRules);
        }
        catch (error) {
        }
    });
}, _Client_connectToSampledStream = async function _Client_connectToSampledStream() {
    const queryParameters = this.options.queryParameters;
    const query = {
        expansions: queryParameters?.tweetExpansions,
        'media.fields': queryParameters?.mediaFields,
        'place.fields': queryParameters?.placeFields,
        'poll.fields': queryParameters?.pollFields,
        'tweet.fields': queryParameters?.tweetFields,
        'user.fields': queryParameters?.userFields,
    };
    const requestData = new structures_1.RequestData({ query, isStreaming: true });
    const res = await this._api.tweets.sample.stream.get(requestData);
    if (!res.body)
        throw Error('No response body');
    const readableStream = node_stream_1.Readable.from(res.body, { encoding: 'utf-8' });
    readableStream.on('data', chunk => {
        try {
            const rawTweet = JSON.parse(chunk);
            const tweet = this.tweets._add(rawTweet.data.id, rawTweet, false);
            this.emit(util_1.ClientEvents.SAMPLED_TWEET_CREATE, tweet);
        }
        catch (error) {
        }
    });
};
const Books = {
    BlockedUsersBook: books_1.BlockedUsersBook,
    ComposedTweetsBook: books_1.ComposedTweetsBook,
    FollowedListsBook: books_1.FollowedListsBook,
    LikedByUsersBook: books_1.LikedByUsersBook,
    LikedTweetsBook: books_1.LikedTweetsBook,
    ListFollowersBook: books_1.ListFollowersBook,
    ListMembersBook: books_1.ListMembersBook,
    ListTweetsBook: books_1.ListTweetsBook,
    MemberOfListsBook: books_1.MemberOfListsBook,
    MutedUsersBook: books_1.MutedUsersBook,
    OwnedListsBook: books_1.OwnedListsBook,
    PinnedListsBook: books_1.PinnedListsBook,
    QuoteTweetsBook: books_1.QuoteTweetsBook,
    RetweetedByUsersBook: books_1.RetweetedByUsersBook,
    SearchTweetsBook: books_1.SearchTweetsBook,
    SpaceTicketBuyersBook: books_1.SpaceTicketBuyersBook,
    TweetsCountBook: books_1.TweetsCountBook,
    UserFollowersBook: books_1.UserFollowersBook,
    UserFollowingsBook: books_1.UserFollowingsBook,
    UserMentioningTweetsBook: books_1.UserMentioningTweetsBook,
};
//# sourceMappingURL=Client.js.map