"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RequestHandler = void 0;
const promises_1 = require("node:timers/promises");
const async_queue_1 = require("@sapphire/async-queue");
const TwitterAPIError_1 = require("./TwitterAPIError");
const util_1 = require("../util");
class RequestHandler {
    constructor(manager) {
        this.manager = manager;
        this.queue = new async_queue_1.AsyncQueue();
    }
    async push(request) {
        await this.queue.wait();
        try {
            return await this.execute(request);
        }
        finally {
            this.queue.shift();
        }
    }
    async execute(request) {
        const res = await request.make();
        if (res.ok) {
            if (request.isStreaming)
                return res;
            const parsedResponse = (await (0, util_1.parseResponse)(res));
            if ('errors' in parsedResponse) {
                if (this.manager.client.options.events.includes('PARTIAL_ERROR')) {
                    this.manager.client.emit(util_1.ClientEvents.PARTIAL_ERROR, parsedResponse.errors);
                }
                if ('data' in parsedResponse === false)
                    throw new TwitterAPIError_1.TwitterAPIError(parsedResponse.errors[0]);
            }
            return parsedResponse;
        }
        else {
            if (request.isStreaming) {
                await (0, promises_1.setTimeout)(20000);
                return this.execute(request);
            }
            const apiError = (await (0, util_1.parseResponse)(res));
            throw new TwitterAPIError_1.TwitterAPIError(apiError);
        }
    }
}
exports.RequestHandler = RequestHandler;
//# sourceMappingURL=RequestHandler.js.map