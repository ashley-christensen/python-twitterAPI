"use strict";
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _TweetsCountBook_instances, _TweetsCountBook_fetchPages;
Object.defineProperty(exports, "__esModule", { value: true });
exports.TweetsCountBook = void 0;
const errors_1 = require("../errors");
const BaseRangeBook_1 = require("./BaseRangeBook");
const structures_1 = require("../structures");
class TweetsCountBook extends BaseRangeBook_1.BaseRangeBook {
    constructor(client, options) {
        super(client, options);
        _TweetsCountBook_instances.add(this);
        this.query = options.query;
        this.granularity = options.granularity ?? null;
    }
    async fetchNextPage() {
        if (!this._hasMadeInitialRequest) {
            this._hasMadeInitialRequest = true;
            return __classPrivateFieldGet(this, _TweetsCountBook_instances, "m", _TweetsCountBook_fetchPages).call(this);
        }
        if (!this._nextToken)
            throw new errors_1.CustomError('PAGINATED_RESPONSE_TAIL_REACHED');
        return __classPrivateFieldGet(this, _TweetsCountBook_instances, "m", _TweetsCountBook_fetchPages).call(this, this._nextToken);
    }
}
exports.TweetsCountBook = TweetsCountBook;
_TweetsCountBook_instances = new WeakSet(), _TweetsCountBook_fetchPages = async function _TweetsCountBook_fetchPages(token) {
    const tweetCountBuckets = [];
    const query = {
        query: this.query,
        next_token: token,
    };
    if (this.granularity)
        query.granularity = this.granularity;
    if (this.afterTweetId)
        query.since_id = this.afterTweetId;
    if (this.beforeTweetId)
        query.until_id = this.beforeTweetId;
    if (this.startTimestamp)
        query.start_time = new Date(this.startTimestamp).toISOString();
    if (this.endTimestamp)
        query.end_time = new Date(this.endTimestamp).toISOString();
    const requestData = new structures_1.RequestData({ query });
    const data = await this.client._api.tweets.counts.recent.get(requestData);
    this._nextToken = data.meta.next_token;
    this.hasMore = data.meta.next_token ? true : false;
    if (data.meta.total_tweet_count === 0)
        return tweetCountBuckets;
    const rawBuckets = data.data;
    for (const rawBucket of rawBuckets) {
        const bucket = new structures_1.TweetCountBucket(rawBucket, this.granularity);
        tweetCountBuckets.push(bucket);
    }
    return tweetCountBuckets;
};
//# sourceMappingURL=TweetsCountBook.js.map