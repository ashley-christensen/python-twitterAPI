import type { APIPlaceGeo, APIPlaceGeoBoundingBox, APIPollOption, APITweetAttachments, APITweetGeo, APITweetGeoCoordinates, APITweetReferencedTweet, APITweetReferencedTweetType, APITweetWithheld, APIUserPublicMetrics, APIUserWithheld, GETTweetsCountsRecentQuery, GETTweetsCountsRecentResponse } from 'twitter-types';
export interface RequestDataOptions<Q, B> {
    /**
     * The query for the request
     */
    query?: Q;
    /**
     * The body for the request
     */
    body?: B;
    /**
     * Whether the request results in a persisent http connection
     */
    isStreaming?: boolean;
    /**
     * Whether the request should be authorized with user context authorization
     */
    isUserContext?: boolean;
}
/**
 * The class for storing data required for generating an API request
 */
export declare class RequestData<Q = undefined, B = undefined> {
    /**
     * The query for the request
     */
    query?: Q;
    /**
     * The body of the request
     */
    body?: B;
    /**
     * Whether the endpoint responds with a stream of data over persisent http connection
     */
    isStreaming?: boolean;
    /**
     * Whether the endpoint need user context authorization
     */
    isUserContext?: boolean;
    constructor(data: RequestDataOptions<Q, B>);
}
export declare class TweetAttachments {
    mediaKeys: Array<string>;
    pollIds: Array<string>;
    constructor(data: APITweetAttachments);
}
export declare class TweetReference {
    /**
     * The relation between this tweet and the referenced tweet
     */
    type: APITweetReferencedTweetType;
    /**
     * The ID of the referenced tweet
     */
    id: string;
    constructor(data: APITweetReferencedTweet);
}
export declare class TweetGeo {
    placeId: string;
    type: 'Point' | null;
    coordinates: TweetGeoCoordinates | null;
    constructor(data: APITweetGeo);
}
export declare class TweetGeoCoordinates {
    latitude: number | null;
    longitude: number | null;
    constructor(data: APITweetGeoCoordinates);
}
export declare class UserPublicMetrics {
    followersCount: number;
    followingCount: number;
    tweetCount: number;
    listedCount: number;
    constructor(data: APIUserPublicMetrics);
}
export declare class PollOption {
    position: number;
    label: string;
    votes: number;
    constructor(data: APIPollOption);
}
export declare class PlaceGeo {
    type: string;
    bbox: APIPlaceGeoBoundingBox;
    properties: Record<string, unknown>;
    constructor(data: APIPlaceGeo);
}
export interface ClientCredentialsInterface {
    consumerKey: string;
    consumerSecret: string;
    accessToken: string;
    accessTokenSecret: string;
    bearerToken: string;
}
export declare class ClientCredentials {
    #private;
    consumerKey: string;
    consumerSecret: string;
    accessToken: string;
    accessTokenSecret: string;
    bearerToken: string;
    constructor(data: ClientCredentialsInterface);
}
export declare class TweetCountBucket {
    /**
     * The start time of the bucket
     */
    start: Date;
    /**
     * The end time of the bucket
     */
    end: Date;
    /**
     * The number of tweets created between start and end time that matched with the query
     */
    count: number;
    /**
     * The timespan between start and end time of this bucket
     */
    granularity: GETTweetsCountsRecentQuery['granularity'];
    constructor(data: GETTweetsCountsRecentResponse['data'][0], granularity: GETTweetsCountsRecentQuery['granularity'] | null);
}
/**
 * Represents withholding details about a user
 */
export declare class UserWitheld {
    /**
     * A list of countries where this content is not available
     */
    countryCodes: Array<string>;
    /**
     * The type of content being withheld
     */
    scope: string | null;
    constructor(data: APIUserWithheld);
}
/**
 * Represents withholding details about a tweet
 */
export declare class TweetWithheld extends UserWitheld {
    /**
     * Whether the content is being withheld on the basis of copyright infringement
     */
    copyright: boolean;
    constructor(data: APITweetWithheld);
}
/**
 * The rule that matched against the filtered tweet
 */
export declare class MatchingRule {
    /**
     * The id of the filter rule
     */
    id: string;
    /**
     * The tag of the filter rule
     */
    tag: string | null;
    constructor(data: {
        id: string;
        tag?: string;
    });
}
//# sourceMappingURL=Miscellaneous.d.ts.map