"use strict";
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _BaseManager_holds;
Object.defineProperty(exports, "__esModule", { value: true });
exports.BaseManager = void 0;
const util_1 = require("../util");
class BaseManager {
    constructor(client, structureType) {
        _BaseManager_holds.set(this, void 0);
        Object.defineProperty(this, 'client', { writable: true, enumerable: false });
        this.client = client;
        this.cache = new util_1.Collection();
        __classPrivateFieldSet(this, _BaseManager_holds, structureType, "f");
    }
    resolve(idOrInstance) {
        if (idOrInstance instanceof __classPrivateFieldGet(this, _BaseManager_holds, "f"))
            return idOrInstance;
        if (typeof idOrInstance === 'string')
            return this.cache.get(idOrInstance) ?? null;
        return null;
    }
    resolveId(idOrInstance) {
        if (idOrInstance instanceof __classPrivateFieldGet(this, _BaseManager_holds, "f"))
            return idOrInstance.id;
        if (typeof idOrInstance === 'string')
            return idOrInstance;
        return null;
    }
    _add(id, data, cacheAfterFetching = true) {
        const entry = new (__classPrivateFieldGet(this, _BaseManager_holds, "f"))(this.client, data);
        if (cacheAfterFetching)
            this.cache.set(id, entry);
        return entry;
    }
}
exports.BaseManager = BaseManager;
_BaseManager_holds = new WeakMap();
//# sourceMappingURL=BaseManager.js.map