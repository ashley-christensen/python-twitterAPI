"use strict";
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _ListManager_instances, _ListManager_fetchSingleListById;
Object.defineProperty(exports, "__esModule", { value: true });
exports.ListManager = void 0;
const BaseManager_1 = require("./BaseManager");
const structures_1 = require("../structures");
const errors_1 = require("../errors");
class ListManager extends BaseManager_1.BaseManager {
    constructor(client) {
        super(client, structures_1.List);
        _ListManager_instances.add(this);
    }
    async create(options) {
        if (typeof options !== 'object')
            throw new errors_1.CustomTypeError('INVALID_TYPE', 'options', 'object', true);
        const body = {
            name: options.name,
            description: options.description,
            private: options.private,
        };
        const requestData = new structures_1.RequestData({ body, isUserContext: true });
        const res = await this.client._api.lists.post(requestData);
        return res.data;
    }
    async fetch(list, options) {
        const listId = this.resolveId(list);
        if (!listId)
            throw new errors_1.CustomError('LIST_RESOLVE_ID', 'fetch');
        return __classPrivateFieldGet(this, _ListManager_instances, "m", _ListManager_fetchSingleListById).call(this, listId, options);
    }
    async delete(list) {
        const listId = this.resolveId(list);
        if (!listId)
            throw new errors_1.CustomError('LIST_RESOLVE_ID', 'delete');
        const requestData = new structures_1.RequestData({ isUserContext: true });
        const res = await this.client._api.lists(listId).delete(requestData);
        return res.data;
    }
    async update(list, options) {
        const listId = this.resolveId(list);
        if (!listId)
            throw new errors_1.CustomError('LIST_RESOLVE_ID', 'update');
        if (typeof options !== 'object')
            throw new errors_1.CustomTypeError('INVALID_TYPE', 'options', 'object', true);
        const body = {
            name: options.name,
            description: options.description,
            private: options.private,
        };
        const requestData = new structures_1.RequestData({ body, isUserContext: true });
        const res = await this.client._api.lists(listId).put(requestData);
        return res.data;
    }
    async addMember(list, user) {
        const listId = this.resolveId(list);
        if (!listId)
            throw new errors_1.CustomError('LIST_RESOLVE_ID', 'add member to');
        const userId = this.client.users.resolveId(user);
        if (!userId)
            throw new errors_1.CustomError('USER_RESOLVE_ID', 'add to the list');
        const body = {
            user_id: userId,
        };
        const requestData = new structures_1.RequestData({ body, isUserContext: true });
        const res = await this.client._api.lists(listId).members.post(requestData);
        return res.data;
    }
    async removeMember(list, member) {
        const listId = this.resolveId(list);
        if (!listId)
            throw new errors_1.CustomError('LIST_RESOLVE_ID', 'remove the member from');
        const userId = this.client.users.resolveId(member);
        if (!userId)
            throw new errors_1.CustomError('USER_RESOLVE_ID', 'remove from the list');
        const requestData = new structures_1.RequestData({ isUserContext: true });
        const res = await this.client._api
            .lists(listId)
            .members(userId)
            .delete(requestData);
        return res.data;
    }
    async follow(list) {
        const listId = this.resolveId(list);
        if (!listId)
            throw new errors_1.CustomError('LIST_RESOLVE_ID', 'follow');
        const loggedInUser = this.client.me;
        if (!loggedInUser)
            throw new errors_1.CustomError('NO_LOGGED_IN_USER');
        const body = {
            list_id: listId,
        };
        const requestData = new structures_1.RequestData({ body, isUserContext: true });
        const res = await this.client._api
            .users(loggedInUser.id)
            .followed_lists.post(requestData);
        return res.data;
    }
    async unfollow(list) {
        const listId = this.resolveId(list);
        if (!listId)
            throw new errors_1.CustomError('LIST_RESOLVE_ID', 'unfollow');
        const loggedInUser = this.client.me;
        if (!loggedInUser)
            throw new errors_1.CustomError('NO_LOGGED_IN_USER');
        const requestData = new structures_1.RequestData({ isUserContext: true });
        const res = await this.client._api
            .users(loggedInUser.id)
            .followed_lists(listId)
            .delete(requestData);
        return res.data;
    }
    async pin(list) {
        const listId = this.resolveId(list);
        if (!listId)
            throw new errors_1.CustomError('LIST_RESOLVE_ID', 'pin');
        const loggedInUser = this.client.me;
        if (!loggedInUser)
            throw new errors_1.CustomError('NO_LOGGED_IN_USER');
        const body = {
            list_id: listId,
        };
        const requestData = new structures_1.RequestData({ body, isUserContext: true });
        const res = await this.client._api
            .users(loggedInUser.id)
            .pinned_lists.post(requestData);
        return res.data;
    }
    async unpin(list) {
        const listId = this.resolveId(list);
        if (!listId)
            throw new errors_1.CustomError('LIST_RESOLVE_ID', 'pin');
        const loggedInUser = this.client.me;
        if (!loggedInUser)
            throw new errors_1.CustomError('NO_LOGGED_IN_USER');
        const requestData = new structures_1.RequestData({ isUserContext: true });
        const res = await this.client._api
            .users(loggedInUser.id)
            .pinned_lists(listId)
            .delete(requestData);
        return res.data;
    }
}
exports.ListManager = ListManager;
_ListManager_instances = new WeakSet(), _ListManager_fetchSingleListById = async function _ListManager_fetchSingleListById(listId, options) {
    if (!options?.skipCacheCheck) {
        const cachedList = this.cache.get(listId);
        if (cachedList)
            return cachedList;
    }
    const queryParameters = this.client.options.queryParameters;
    const query = {
        expansions: queryParameters?.listExpansions,
        'list.fields': queryParameters?.listFields,
        'user.fields': queryParameters?.userFields,
    };
    const requestData = new structures_1.RequestData({ query });
    const res = await this.client._api.lists(listId).get(requestData);
    return this._add(res.data.id, res, options?.cacheAfterFetching);
};
//# sourceMappingURL=ListManager.js.map