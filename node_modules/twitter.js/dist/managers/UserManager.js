"use strict";
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _UserManager_instances, _UserManager_fetchSingleUserById, _UserManager_fetchMultipleUsersByIds, _UserManager_fetchSingleUserByUsername, _UserManager_fetchMultipleUsersByUsernames;
Object.defineProperty(exports, "__esModule", { value: true });
exports.UserManager = void 0;
const util_1 = require("../util");
const BaseManager_1 = require("./BaseManager");
const errors_1 = require("../errors");
const structures_1 = require("../structures");
class UserManager extends BaseManager_1.BaseManager {
    constructor(client) {
        super(client, structures_1.User);
        _UserManager_instances.add(this);
    }
    resolve(userResolvable) {
        const user = super.resolve(userResolvable);
        if (user)
            return user;
        if (userResolvable instanceof structures_1.SimplifiedUser)
            return super.resolve(userResolvable.id);
        if (userResolvable instanceof structures_1.Tweet || userResolvable instanceof structures_1.SimplifiedTweet) {
            return userResolvable.authorId ? super.resolve(userResolvable.authorId) : null;
        }
        return null;
    }
    resolveId(userResolvable) {
        const userId = super.resolveId(userResolvable);
        if (typeof userId === 'string')
            return userId;
        if (userResolvable instanceof structures_1.SimplifiedUser)
            return userResolvable.id;
        if (userResolvable instanceof structures_1.Tweet || userResolvable instanceof structures_1.SimplifiedTweet)
            return userResolvable.authorId;
        return null;
    }
    async fetch(userOrUsers, options) {
        if (Array.isArray(userOrUsers)) {
            const userIds = userOrUsers.map(user => {
                const userId = this.resolveId(user);
                if (!userId)
                    throw new errors_1.CustomError('USER_RESOLVE_ID', 'fetch');
                return userId;
            });
            return __classPrivateFieldGet(this, _UserManager_instances, "m", _UserManager_fetchMultipleUsersByIds).call(this, userIds, options);
        }
        const userId = this.resolveId(userOrUsers);
        if (!userId)
            throw new errors_1.CustomError('USER_RESOLVE_ID', 'fetch');
        return __classPrivateFieldGet(this, _UserManager_instances, "m", _UserManager_fetchSingleUserById).call(this, userId, options);
    }
    async fetchByUsername(usernameOrUsernames, options) {
        if (Array.isArray(usernameOrUsernames)) {
            const usernames = usernameOrUsernames.map(username => {
                if (typeof username !== 'string')
                    throw new errors_1.CustomTypeError('INVALID_TYPE', 'username in the usernames array', 'string', false);
                return username;
            });
            return __classPrivateFieldGet(this, _UserManager_instances, "m", _UserManager_fetchMultipleUsersByUsernames).call(this, usernames, options);
        }
        if (typeof usernameOrUsernames !== 'string')
            throw new errors_1.CustomTypeError('INVALID_TYPE', 'username', 'string', false);
        return __classPrivateFieldGet(this, _UserManager_instances, "m", _UserManager_fetchSingleUserByUsername).call(this, usernameOrUsernames, options);
    }
    async follow(user) {
        const userId = this.resolveId(user);
        if (!userId)
            throw new errors_1.CustomError('USER_RESOLVE_ID', 'follow');
        const loggedInUser = this.client.me;
        if (!loggedInUser)
            throw new errors_1.CustomError('NO_LOGGED_IN_USER');
        const body = {
            target_user_id: userId,
        };
        const requestData = new structures_1.RequestData({ body, isUserContext: true });
        const res = await this.client._api.users(loggedInUser.id).following.post(requestData);
        return res.data;
    }
    async unfollow(user) {
        const userId = this.resolveId(user);
        if (!userId)
            throw new errors_1.CustomError('USER_RESOLVE_ID', 'unfollow');
        const loggedInUserId = this.client.me?.id;
        if (!loggedInUserId)
            throw new errors_1.CustomError('NO_LOGGED_IN_USER');
        const requestData = new structures_1.RequestData({ isUserContext: true });
        const res = await this.client._api
            .users(loggedInUserId)
            .following(userId)
            .delete(requestData);
        return res.data;
    }
    async block(user) {
        const userId = this.resolveId(user);
        if (!userId)
            throw new errors_1.CustomError('USER_RESOLVE_ID', 'block');
        const loggedInUserId = this.client.me?.id;
        if (!loggedInUserId)
            throw new errors_1.CustomError('NO_LOGGED_IN_USER');
        const body = {
            target_user_id: userId,
        };
        const requestData = new structures_1.RequestData({ body, isUserContext: true });
        const res = await this.client._api.users(loggedInUserId).blocking.post(requestData);
        return res.data;
    }
    async unblock(user) {
        const userId = this.resolveId(user);
        if (!userId)
            throw new errors_1.CustomError('USER_RESOLVE_ID', 'unblock');
        const loggedInUserId = this.client.me?.id;
        if (!loggedInUserId)
            throw new errors_1.CustomError('NO_LOGGED_IN_USER');
        const requestData = new structures_1.RequestData({ isUserContext: true });
        const res = await this.client._api
            .users(loggedInUserId)
            .blocking(userId)
            .delete(requestData);
        return res.data;
    }
    async mute(user) {
        const userId = this.resolveId(user);
        if (!userId)
            throw new errors_1.CustomError('USER_RESOLVE_ID', 'mute');
        const loggedInUserId = this.client.me?.id;
        if (!loggedInUserId)
            throw new errors_1.CustomError('NO_LOGGED_IN_USER');
        const body = {
            target_user_id: userId,
        };
        const requestData = new structures_1.RequestData({ body, isUserContext: true });
        const res = await this.client._api.users(loggedInUserId).muting.post(requestData);
        return res.data;
    }
    async unmute(user) {
        const userId = this.resolveId(user);
        if (!userId)
            throw new errors_1.CustomError('USER_RESOLVE_ID', 'unmute');
        const loggedInUserId = this.client.me?.id;
        if (!loggedInUserId)
            throw new errors_1.CustomError('NO_LOGGED_IN_USER');
        const requestData = new structures_1.RequestData({ isUserContext: true });
        const res = await this.client._api
            .users(loggedInUserId)
            .muting(userId)
            .delete(requestData);
        return res.data;
    }
}
exports.UserManager = UserManager;
_UserManager_instances = new WeakSet(), _UserManager_fetchSingleUserById = async function _UserManager_fetchSingleUserById(userId, options) {
    if (!options?.skipCacheCheck) {
        const cachedUser = this.cache.get(userId);
        if (cachedUser)
            return cachedUser;
    }
    const queryParameters = this.client.options.queryParameters;
    const query = {
        expansions: queryParameters?.userExpansions,
        'tweet.fields': queryParameters?.tweetFields,
        'user.fields': queryParameters?.userFields,
    };
    const requestData = new structures_1.RequestData({ query });
    const res = await this.client._api.users(userId).get(requestData);
    return this._add(res.data.id, res, options?.cacheAfterFetching);
}, _UserManager_fetchMultipleUsersByIds = async function _UserManager_fetchMultipleUsersByIds(userIds, options) {
    const fetchedUsers = new util_1.Collection();
    const queryParameters = this.client.options.queryParameters;
    const query = {
        ids: userIds,
        expansions: queryParameters?.userExpansions,
        'tweet.fields': queryParameters?.tweetFields,
        'user.fields': queryParameters?.userFields,
    };
    const requestData = new structures_1.RequestData({ query });
    const res = await this.client._api.users.get(requestData);
    const rawUsers = res.data;
    const rawUsersIncludes = res.includes;
    for (const rawUser of rawUsers) {
        const user = this._add(rawUser.id, { data: rawUser, includes: rawUsersIncludes }, options?.cacheAfterFetching);
        fetchedUsers.set(user.id, user);
    }
    return fetchedUsers;
}, _UserManager_fetchSingleUserByUsername = async function _UserManager_fetchSingleUserByUsername(username, options) {
    if (!options?.skipCacheCheck) {
        const cachedUser = this.cache.find(user => user.username === username);
        if (cachedUser)
            return cachedUser;
    }
    const queryParameters = this.client.options.queryParameters;
    const query = {
        expansions: queryParameters?.userExpansions,
        'tweet.fields': queryParameters?.tweetFields,
        'user.fields': queryParameters?.userFields,
    };
    const requestData = new structures_1.RequestData({ query });
    const res = await this.client._api.users.by.username(username).get(requestData);
    return this._add(res.data.id, res, options?.cacheAfterFetching);
}, _UserManager_fetchMultipleUsersByUsernames = async function _UserManager_fetchMultipleUsersByUsernames(usernames, options) {
    const fetchedUsers = new util_1.Collection();
    const queryParameters = this.client.options.queryParameters;
    const query = {
        usernames,
        expansions: queryParameters?.userExpansions,
        'tweet.fields': queryParameters?.tweetFields,
        'user.fields': queryParameters?.userFields,
    };
    const requestData = new structures_1.RequestData({ query });
    const res = await this.client._api.users.by.get(requestData);
    const rawUsers = res.data;
    const rawUsersIncludes = res.includes;
    for (const rawUser of rawUsers) {
        const user = this._add(rawUser.id, { data: rawUser, includes: rawUsersIncludes }, options?.cacheAfterFetching);
        fetchedUsers.set(user.id, user);
    }
    return fetchedUsers;
};
//# sourceMappingURL=UserManager.js.map